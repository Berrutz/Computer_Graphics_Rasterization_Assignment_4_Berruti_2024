
Caso Base :
"Camera":
	{
		"IsPerspective": false,
		"Position": [0, 0, -2],
		"FieldOfView": 0.5853,
		"Near": -1,
		"FocalLength": 3,
		"Far": -4,
		"Target": [0, 0 , 0],
		"UpVector": [0, 1, 0],
		"LensRadius": 0.0
},
{
			"Material": 0,
			"Type": "Mesh",
			"Path": "bunny.off",
			"angle_x": 0,
			"angle_y": 0,
			"angle_z": 0,
			"translation": [0, -0.5 , 0],        // traslato 
			"scale": [6, 6, 6]
}

ORTOGRAFICA:



NORMALI :
è piu correta v1 - v0 cross v2 - v0 o viceversa ? o è uguale ?

La normale inanzitutto è un vettore che punta verso l'ESTERNO del 
modello verso le luci , percio soprattutto per le facce dietro è meglio fare un check 
volta per volta .


3 OPZIONI
normal = (v2 - v0).cross(v1 - v0).normalized();

normal = (v1 - v0).cross(v2 - v0).normalized();

normal = (v0 - v1).cross(v0 - v2).normalized();   //  da escludere 

getchar();

Normal 1 : 0.106921 -0.98898 0.102406    
Normal 2 : -0.106921   0.98898 -0.102406
Normal 3 : -0.106921   0.98898 -0.102406         //  da escludere come caso non si fa cosi 

Per capirlo prendo 3 vertici a caso 
Calcolo la Normale 1 

Poi sapendo che il centro del modello è in (0,0,0)
Prendo uno dei 3 vertici ( potrei fare anche la media per trovare il centro)
e calcolo il vettore v che va dal quel vertice verso l'interno 

Ora confronto quel vettore v con la normale attraverso il prodotto SCALARE
se il prodotto tra i due è positivo i vertici sono in senso anti orario

PRODOTTO SCALARE :
Simmetria: 
 a ⋅ b = b ⋅ a

Valore Positivo
Se il prodotto scalare è maggiore di zero, significa 
che l’angolo tra i due vettori è acuto 
( 0 ∘ ≤θ <90∘). 
I vettori puntano più o meno nella stessa direzione.

se il prodotto è negativo sono in senso orario 
Se il prodotto scalare è minore di zero, l’angolo tra i vettori 
è ottuso (90 <θ≤180 ∘). 
I vettori puntano in direzioni opposte.


------------------------

DEBUG WIREFRAME 

in load_off in vertices_wireframe 
inserisce 3 coppie di vertici 

vertex_attributes_wire.push_back(VertexAttributes(a[0],a[1],a[2]));
vertex_attributes_wire.push_back(VertexAttributes(b[0],b[1],b[2]));

vertex_attributes_wire.push_back(VertexAttributes(b[0],b[1],b[2]));
vertex_attributes_wire.push_back(VertexAttributes(c[0],c[1],c[2]));

vertex_attributes_wire.push_back(VertexAttributes(c[0],c[1],c[2]));
vertex_attributes_wire.push_back(VertexAttributes(a[0],a[1],a[2]));

Che rappresentano un triangolo T con 3 vertici A,B,C , crea le 3 linee 
da A,B da B,C da C ad A

quando torna nel main() usa rasterize_lines

// Draw lines between vertices su vertex_attributes_wire
float thickness =  1.0;
rasterize_lines(program, uniform, vertex_attributes_wire,thickness, frameBuffer);

Fine main 

Dopo aver rasterizzato le linee passa per Vertex Shader , Fragment shader , Blending shader

In Vertex Shader Calcolo posizione finale e normale finale 

Mfinal = uniform.projection_matrix * uniform.camera_matrix * uniform.model_matrix;
Mfinal_inv_transpose =  uniform.projection_matrix_inv_transpose  * uniform.camera_matrix_inv_transpose * uniform.model_matrix_inv_transpose;

FinalPosition = Mfinal * va.position;
FinalNormal = (Mfinal_inv_transpose * va.normal).normalized();

out.position = FinalPosition;
out.normal  = FinalNormal;

// Ho anche provato che eseguire il prodotto delle inverse trasposte di model , camera e projection 
// è lo stesso che farlo una per uno in Vertex shader , ricordarsi di normalizzare alla fine 
// Slide 8 page 26
// Idea creare una funzione per trovare inversa EFFICENTE per roto traslazione e usarla non solo per camera 
// provare se c'è tempo 


In FragmentShader :
Prima trovo il materiale dell'oggetto il base all'indice 

UniformAttributes::Material mat = uniform.materials[uniform.object_material_index]; 

POI prendo il colore dell'ambiente e uso quello e passo anche la posizione invariata in WIREFRAME
passando il valore dall'oggetto VertexAttribute a FragmentAttributes

FragmentAttributes out(C(0),C(1),C(2));


In Blending Shader :

Valuto la posizione della z del FragmentAttributes fa (colore e posizione )
rispetto al precedente FrameBufferAttributes previous 

Se la profondità è minore della precedente coloro il frame attuale out 
con il suo colore e aggiorno 
la posizione della z

---------------------------------------------------------------------

TEST SU WIREFRAME :
Partendo dal CASO BASE modifico alcune righe del JSON :

ORTOGRAFICA:
ruotare su Y : "angle_y": -0.5                                         LO FA COERENTEMENTE

Allontanare il Far Plane : "Far": -10                                  LO FA COERENTEMENTE perche se proiettica non vedo differenze 

Allontanare la posizione camera : "Position": [0, 0, -4],              
LO FA COERENTEMENTE , allontando la telecamera alcuni rimangono fuori dalla bar essendo il Far Plane a distanza -4
Perciò visualizza solo quella parte dei triangoli che rappresentano il fronte 

Allontanare ancora la posizione camera : "Position": 
"Position": [0, 0, -4.2],  
LO FA COERENTEMENTE , allontanando la telecamera alcuni rimangono fuori solo orecchie e una parte della gamba si vedono
"Base_case_Posz-4.2.png" nella cartella "img/ex2/wireframe/ortograhic"
Ovviamente se allungo il far plane tipo a -6 rivedo tutto il coniglio 


Target [0,-0.5,0] : Modifico dove viene fissato l'asse della telecamera , Ovviamente 
essendo l'asse della z piu in basso il coniglio rimarra piu in alto ed è cosi . LO FA CORRETTAMENTE 

Prove che mi vengono in mente passate 

Un altro esempio sarebbe modificando l'aspect ratio ma gia sull'esercizio 1 andava bene 


PROSPETTICA :

Caso base , LO FA CORRETTAMENTE a livello geometrico con i parametri attuali ( da rivedere )

Ora il caso base diventa con traslazione sulle x del modello per averlo al centro
"translation": [0.5, 0 , 0] 

Cambiando theta 
"FieldOfView": 0.7853
LO FA CORRETTAMENTE , aumentando l'angolo di visualizzazione allora il Near Plane 
sarà piu grosso e anche il Far come estremi l,b,n,f e quindi l'oggetto sembrera piu piccolo e anche vicevarsa funziona 


Cambiando il Far Plane (dipende dalla distanza focale )
"FocalLength": 10,
LO FA CORRETTAMENTE , se allontano il Far Plane il coniglio si rimpicciolisce e rimane in basso a sinistra 

Allontanando la telecamera:
"Position": [0, 0, -2.5]
LO FA COERENTEMENTE , se aumento la distanza l'oggetto rimane piu piccolo 

Modifica di Target :
"Target": [0, -0,5 , 0],
LO FA COERENTEMENTE , l'asse z è rivolto verso il basso quindi coniglio si vede in alto 




----------------------------------------------------------------------



EX 2.2 
DEBUG FLAT SHADING :

Inanzitutto si calcolano le normali per la faccia e non per i vertici quello dopo

Vector3f normal = Face_normals.row( i );
Vector4f normal_4d;
normal_4d << normal, 0.0f;

in load_off() in vertex_attributes_flat inserisce solo 3 vertici per ogni triangolo 

vertex_attributes_flat.push_back(VertexAttributes(a[0],a[1],a[2],1.0,normal_4d));
vertex_attributes_flat.push_back(VertexAttributes(b[0],b[1],b[2],1.0,normal_4d));
vertex_attributes_flat.push_back(VertexAttributes(c[0],c[1],c[2],1.0,normal_4d));

e sopra va a mettere in load_off() in vertices_wireframe inserisce 3 coppie vertici come in WIREFRAME , li va a mettere sopra 

vertex_attributes_wire.push_back(VertexAttributes(a[0],a[1],a[2]));
vertex_attributes_wire.push_back(VertexAttributes(b[0],b[1],b[2]));

vertex_attributes_wire.push_back(VertexAttributes(b[0],b[1],b[2]));
vertex_attributes_wire.push_back(VertexAttributes(c[0],c[1],c[2]));

vertex_attributes_wire.push_back(VertexAttributes(c[0],c[1],c[2]));
vertex_attributes_wire.push_back(VertexAttributes(a[0],a[1],a[2]));


Tornati nel main 
RASTERIZZA PRIMA I TRIANGOLI in vertex_attributes_flat
rasterize_triangles(program,uniform,vertex_attributes_flat,frameBuffer);

E poi RASTERIZZA le LINEE SOPRA :
shadingMode = WIREFRAME;                                // useful in other function such as BlendingShader and FragmentShader 
uniform.object_material_index = 1;                      // change color of the WIREFRAME

rasterize_lines(program,uniform,vertex_attributes_wire,thickness,frameBuffer);

COME VEDI SERVONO PER FORZA 2 STRUTTURE DIVERSE PER RASTERIZZARE  vertex_attributes_wire  ,  vertex_attributes_flat



Fine main 

Dopo aver rasterizzato le linee passa per Vertex Shader , Fragment shader , Blending shader

VERTEX SHADER :

Calcolo posizione finale e normale finale come per WIREFRAME 

FinalPosition = Mfinal * va.position;
FinalNormal = (Mfinal_inv_transpose * va.normal).normalized();

out.position = FinalPosition;
out.normal  = FinalNormal;

FRAGMENT SHADER :
Prima trovo il materiale dell'oggetto il base all'indice 

UniformAttributes::Material mat = uniform.materials[uniform.object_material_index]; 

Allora ho letto l'ex3 e ex4 e ho visto che il calcolo dell''illuminazione va fatta nello spazio della camera e nel Vertex Shader 
, non come ha fatto alex che ha riconvertito nello spazio della camera nel Fragment Shader 
Ah e bisogna trasformare nel Vertex Shader tutti i punti , anche quelli della luce 
che sono in coordinate del mondo a quelle della camera 

PERCIO ORA IL FRAGMENT SARA CORTISSIMO , MA SI ALLUNGA IL VERTEX SHADER 

RICALCOLO DELLE NORMALI nella funzione computer normal da v0 - center_of_the_model  , tutto fatto nel SDF del modello
Meglio avere i vettori in 3D cosi  copio codice Assignment 2 soprattutto perche quando arrivi alla sezione delle intensità 
come gestisci la quarta componente ?

SI DEVE PER FORZA FARE DOVE Uniform e va sono const , quidni metterlo in out se voglio passsare qualcosa 
perche serve il va.position 

In interpolate passava 0000 e non capivo perche , era perche in interpolate NON gestivo il colore dei 3 vertici


In qualche modo faatto ,
ESATTO IL CALCOLO DELLA NORMALE 

Unico dubbio sulla MATRICE PROIETTICA da valori piccoli e-07 ma le matrici P e ortographic sono giuste


---------------------------------------------------------------------------------------------

TEST su FLAT SHADING

Partendo dal CASO BASE modifico alcune righe del JSON :

{
	"Scene":
	{
		"Background": [0.3, 0.3, 0.9],
		"Ambient": [0.7 , 0.7 ,0.7]
	},
	"Camera":
	{
		"IsPerspective": true,
		"Position": [0, 0, -2],
		"FieldOfView": 0.5853,
		"Near": -1,
		"FocalLength": 3,
		"Far": -4,
		"Target": [0, 0 , 0],
		"UpVector": [0, 1, 0],
		"LensRadius": 0.0
	},
	"Materials": [
		{
			"Color": [1, 1, 0, 1],
            "Ambient": [0, 1, 0],
			"Diffuse": [0.5, 0.5, 0.5],
			"Specular": [0.3, 0.3, 0.3],
			"Mirror": [0.8, 0.8, 0.8],
			"Refraction": [0.9, 0.9, 0.9],
			"RefractionIndex": 10.0,
			"Shininess": 10.0
		},
		{
			"Color": [0, 0, 1, 1],
            "Ambient": [1, 0, 0],
			"Diffuse": [0.2, 0.2, 0.2],
			"Specular": [0.3, 0.3, 0.3],
			"Mirror": [0.5, 0.5, 0.5],
			"Refraction": [0.9, 0.9, 0.9],
			"RefractionIndex": 10.0,
			"Shininess": 10.0
		}
	],
	"Lights": [
		{
			"Position": [0, 0, -5],
			"Color": [0.5, 0.5, 0.5]              
		}
	],
	"Objects": [
		{
			"Material": 0,
			"Type": "Mesh",
			"Path": "bunny.off",
			"angle_x": 0,
			"angle_y": 0,
			"angle_z": 0,
			"translation": [0, 0 , 0],
			"scale": [6, 6, 6]
		}
	]
}


ORTOGRAFICA:
"IsPerspective": false,

Cambiare il colore della luce                                          OK funziona

Cambiare il colore del materiale AMBIENT della Mesh                    OK funziona

ruotare su Y : "angle_y": -0.5                                         LO FA COERENTEMENTE

rouatre su z 														   LO FA COERENTEMENTE

Allontanare il Far Plane : "Far": -10                                  LO FA COERENTEMENTE perche se proiettica non vedo differenze 

Avvicino il Near Plane : "Near" : -2                                   LO FA COERENTEMENTE e taglia fuori alcuni punti 

Allontanare la posizione camera : "Position": [0, 0, -4],              
LO FA COERENTEMENTE , allontando la telecamera alcuni punti rimangono fuori dalla bar essendo il Far Plane a distanza -4
Perciò visualizza solo quella parte dei triangoli che rappresentano il fronte 

Allontanare ancora la posizione camera : "Position": 
"Position": [0, 0, -4.2],  
LO FA COERENTEMENTE , allontanando la telecamera alcuni rimangono fuori solo orecchie e una parte della gamba si vedono
"Base_case_Posz-4.2.png" nella cartella "img/ex2/wireframe/ortograhic"
Ovviamente se allungo il far plane tipo a -6 rivedo tutto il coniglio 


Target [0,-0.5,0] : Modifico dove viene fissato l'asse della telecamera , Ovviamente 
essendo l'asse della z piu in basso il coniglio rimarra piu in alto ed è cosi . LO FA CORRETTAMENTE 

Prove che mi vengono in mente passate 

Un altro esempio sarebbe modificando l'aspect ratio ma gia sull'esercizio 1 andava bene 


PROSPETTICA :

Caso base , LO FA CORRETTAMENTE a livello geometrico con i parametri attuali ( da rivedere )
"IsPerspective": true 

Ora il caso base diventa con traslazione sulle x del modello per averlo al centro
"translation": [0.5, 0 , 0] 

Ruotare su Y 														- funziona  ok

Cambiando theta 
"FieldOfView": 0.7853
LO FA CORRETTAMENTE , aumentando l'angolo di visualizzazione allora il Near Plane 
sarà piu grosso e anche il Far come estremi l,b,n,f e quindi l'oggetto sembrera piu piccolo e anche vicevarsa funziona 


Cambiando il Far Plane (dipende dalla distanza focale )
"FocalLength": 10,
LO FA CORRETTAMENTE , se allontano il Far Plane il coniglio si rimpicciolisce e rimane in basso a sinistra 

Allontanando la telecamera:
"Position": [0, 0, -2.5]
LO FA COERENTEMENTE , se aumento la distanza l'oggetto rimane piu piccolo 

Modifica di Target :
"Target": [0, -0,5 , 0],
LO FA COERENTEMENTE , l'asse z è rivolto verso il basso quindi coniglio si vede in alto 

CAMBIO DELLA LUCE :
"Color": [1, 0, 0]    					   FUNZIONA CORRETTAMENTE

CAMBIO DELLA P E LUCE :                    FUNZIONA CORRETTAMENTE
"Shininess" : 100.0 

DIFFUSE TO ZERO 
"Diffuse": [0, 0, 0]                       FUNZIONA COERENTEMENTE

SPECULAR TO ZERO 
"Specular": [0, 0, 0]                      FUNZIONA COERENTEMENTE


-----------------------------------------------------------------------------------

TEST SU PER VERTEX 

ORTO:

{
	"Scene":
	{
		"Background": [0.3, 0.3, 0.9],
		"Ambient": [0.5 , 0.5 ,0.5]
	},
	"Camera":
	{
		"IsPerspective": false ,
		"Position": [0, 0, -2],
		"FieldOfView": 0.5853,
		"Near": -1,
		"FocalLength": 3,
		"Far": -4,
		"Target": [0, 0 , 0],
		"UpVector": [0, 1, 0],
		"LensRadius": 0.0
	},
	"Materials": [
		{
			"Color": [0.5, 0.5, 0.5, 1],
            "Ambient": [0.01, 0.01, 0.01],
			"Diffuse": [0.5, 0.5, 0.5],
			"Specular": [0.5, 0.5, 0.5],
			"Mirror": [0.8, 0.8, 0.8],
			"Refraction": [0.9, 0.9, 0.9],
			"RefractionIndex": 10.0,
			"Shininess": 1.0
		},
		{
			"Color": [0.5, 0.5, 0.5, 1],
            "Ambient": [0.5, 0.5, 0.5],
			"Diffuse": [0.2, 0.2, 0.2],
			"Specular": [0.3, 0.3, 0.3],
			"Mirror": [0.5, 0.5, 0.5],
			"Refraction": [0.9, 0.9, 0.9],
			"RefractionIndex": 10.0,
			"Shininess": 10.0
		}
	],
	"Lights": [
		{
			"Position": [0.3, 0.5, -2.2],
			"Color": [2, 2 , 2],   
			"BaseColor": [0.5, 0.25, 0.25]             
		}
	],
	"Objects": [
		{
			"Material": 0,
			"Type": "Mesh",
			"Path": "bunny.off",
			"angle_x": 0,
			"angle_y": 0.5,
			"angle_z": 0,
			"translation": [0, -0.5 , 0],
			"scale": [6, 6, 6]
		}
	]
}


ORTOGRAFICA:
"IsPerspective": false,

CASO BASE 															   FUNZIONA - È COME NELL'Assignment PIU O meno
																	   LA NORMALE È TROPPO PICCOLA IL COLORE È POCO NERO NELLE ZONE D'OMBRA

Cambiare il colore della luce                                          OK funziona
"Color": [0, 2 , 0],  
OK,IMG

Cambiare il colore del materiale AMBIENT della Mesh                    OK funziona
"Ambient": [0.01, 0.8, 0.01],
OK , IMG

ruotare su Y : "angle_y": -0.5                                         LO FA COERENTEMENTE 
"angle_y": 0.5,
HO IMG

Ruotare su z 														   LO FA COERENTEMENTE
"angle_z": 1,
HO IMG

Allontanare il Far Plane : "Far": -10                                  
LO FA COERENTEMENTE perche se proiettica non vedo differenze MENTRE se lo avvicino -3
HO IMG
Sembra al contrario taglia fuori i punti dietro 

Avvicino il Near Plane : "Near" : -2                                   
LO FA COERENTEMENTE e taglia fuori alcuni punti 
HO IMG

Allontanare la posizione camera : "Position": [0, 0, -4],              
LO FA COERENTEMENTE , allontando la telecamera alcuni punti rimangono fuori dalla 
bar essendo il Far Plane a distanza -4
Perciò visualizza solo quella parte dei triangoli che rappresentano il fronte .



Allontanare ancora la posizione camera : "Position": 
"Position": [0, 0, -4.2],  
LO FA COERENTEMENTE , allontanando la telecamera alcuni rimangono fuori solo orecchie 
e una parte della gamba si vedono
"Base_case_Posz-4.2.png" nella cartella "img/ex2/wireframe/ortograhic"
Ovviamente se allungo il far plane tipo a -6 rivedo tutto il coniglio 
NON LO FA 

Target [0,-0.5,0] : Modifico dove viene fissato l'asse della telecamera , Ovviamente 
essendo l'asse della z piu in basso il coniglio rimarra piu in alto ed è cosi . LO FA CORRETTAMENTE 
IMG , LO FA 

Prove che mi vengono in mente passate 

Un altro esempio sarebbe modificando l'aspect ratio ma gia sull'esercizio 1 andava bene 

-----------------------------------------------------------------------------------------------------------

Partendo dal CASO BASE PROJ modifico alcune righe del JSON :

{
	"Scene":
	{
		"Background": [0.3, 0.3, 0.9],
		"Ambient": [0.5 , 0.5 ,0.5]
	},
	"Camera":
	{
		"IsPerspective": false ,
		"Position": [0, 0, -2],
		"FieldOfView": 0.5853,
		"Near": -1,
		"FocalLength": 3,
		"Far": -4,
		"Target": [0, 0 , 0],
		"UpVector": [0, 1, 0],
		"LensRadius": 0.0
	},
	"Materials": [
		{
			"Color": [0.5, 0.5, 0.5, 1],
            "Ambient": [0.5, 0.5, 0.5],
			"Diffuse": [0.2, 0.2, 0.2],
			"Specular": [0.2, 0.2, 0.2],
			"Mirror": [0.8, 0.8, 0.8],
			"Refraction": [0.9, 0.9, 0.9],
			"RefractionIndex": 10.0,
			"Shininess": 5.0
		},
		{
			"Color": [0.5, 0.5, 0.5, 1],
            "Ambient": [0.5, 0.5, 0.5],
			"Diffuse": [0.2, 0.2, 0.2],
			"Specular": [0.3, 0.3, 0.3],
			"Mirror": [0.5, 0.5, 0.5],
			"Refraction": [0.9, 0.9, 0.9],
			"RefractionIndex": 10.0,
			"Shininess": 10.0
		}
	],
	"Lights": [
		{
			"Position": [0.5, 2, -3],
			"Color": [5, 5 , 5],   
			"BaseColor": [0.5, 0.25, 0.25]             
		}
	],
	"Objects": [
		{
			"Material": 0,
			"Type": "Mesh",
			"Path": "bunny.off",
			"angle_x": 0,
			"angle_y": 0.5,
			"angle_z": 0,
			"translation": [0, -0.5 , 0],
			"scale": [6, 6, 6]
		}
	]
}


PROSPETTICA :

Caso base , LO FA CORRETTAMENTE a livello geometrico con i parametri attuali RIVISTO OK
"IsPerspective": true 

Ora il caso base diventa con traslazione sulle x del modello per averlo al centro
"translation": [0.5, 0 , 0]                                                        OK , HO IMG

Ruotare su Y 														- funziona  ok ,  OK , HO IMG

Cambiando theta 
"FieldOfView": 0.7853
LO FA CORRETTAMENTE , aumentando l'angolo di visualizzazione allora il Near Plane 
sarà piu grosso e anche il Far come estremi l,b,n,f e quindi l'oggetto sembrera piu piccolo e anche vicevarsa funziona 
HO IMG


Cambiando il Far Plane (dipende dalla distanza focale )
"FocalLength": 10,
LO FA CORRETTAMENTE , se allontano il Far Plane il coniglio si rimpicciolisce e rimane in basso a sinistra 
HO IMG 

Allontanando la telecamera:
"Position": [0, 0, -2.5]
LO FA COERENTEMENTE , se aumento la distanza l'oggetto rimane piu piccolo 
HO IMG

Modifica di Target :
"Target": [0, -0,5 , 0],
LO FA COERENTEMENTE , l'asse z è rivolto verso il basso quindi coniglio si vede in alto 
HO IMG


CAMBIO DELLA LUCE :
"Color": [1, 0, 0]    					   FUNZIONA CORRETTAMENTE
HO IMG

CAMBIO DELLA P E LUCE :                    FUNZIONA CORRETTAMENTE
"Shininess" : 100.0 
HO IMG

DIFFUSE TO ZERO 
"Diffuse": [0, 0, 0]                       FUNZIONA COERENTEMENTE
HO IMG

SPECULAR TO ZERO 
"Specular": [0, 0, 0]                      FUNZIONA COERENTEMENTE
HO IMG , NON CAMBIA NULLA RIVEDERE 


------------------------------------------------------------------------------------

PROBLEMA GIGANTESCO PER FARE PER FARE PER VERTEX SHADING 

DEVO FARE INTERPOLATE CON ALFA BETA GAMMA E QUIDNI PER FORZA IL CALCOLO 
DELL'ILLUMINAZIONE NON PUO ESSERE FATTO IN VERTEX SHADING 
E BISOGNA TORNARE INDIETRO CON LA TRASFORMAZIONE 

PERCHE ALFA , BETA , GAMMA SONO DEDOTTI NEL RASTER. CPP E PASSATI SOLO A INTERPOLATE 

DATO CHE POI CE UN IF DOPO INTERPOLATE BISOGNA PRIMA PASSARE LE POSIZIONI 
TRASFORMATE IN ORTO O PROJ E DOPO TORNARE INDIETRO IN CAMERA SPACE

ricordare che la posizione della luce è in WORLD coordinate SYS 
quindi non viene usata la matrice del modello per questo nel JSON 
potrebbe avere valori che non hanno molto senso perche gli assi sono 
diversi [-1,-0.5,-3]

-------------------------------------------------------------------------------------




			



